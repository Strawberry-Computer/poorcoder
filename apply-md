#!/bin/bash

# apply-md - Markdown Code Applier
# Extracts code blocks from markdown and applies changes to the filesystem

# Default values
DRY_RUN=false
CREATE_MISSING=false
BACKUP=false
BACKUP_DIR="./.backups"
FILE_MARKER='^```[a-z]+ (.+)$'
SKIP_UNCHANGED=false
VERBOSE=false
CONFIRM=false
ONLY_FILES=""
IGNORE_FILES=""

# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --dry-run) DRY_RUN=true; shift ;;
        --create-missing) CREATE_MISSING=true; shift ;;
        --backup) BACKUP=true; shift ;;
        --backup-dir=*) BACKUP_DIR="${1#*=}"; shift ;;
        --file-marker=*) FILE_MARKER="${1#*=}"; shift ;;
        --skip-unchanged) SKIP_UNCHANGED=true; shift ;;
        --verbose) VERBOSE=true; shift ;;
        --confirm) CONFIRM=true; shift ;;
        --only-files=*) ONLY_FILES="${1#*=}"; shift ;;
        --ignore-files=*) IGNORE_FILES="${1#*=}"; shift ;;
        --help|-h)
            echo "Usage: ./apply-md [options]"
            echo ""
            echo "Options:"
            echo "  --dry-run                 Preview changes without applying them"
            echo "  --create-missing          Create files that don't exist"
            echo "  --backup                  Create backup files before applying changes"
            echo "  --backup-dir=<dir>        Directory for backups (default: ./.backups)"
            echo "  --file-marker=<regex>     Regex to identify target files from markdown"
            echo "  --skip-unchanged          Skip files with no changes"
            echo "  --verbose                 Show detailed output about changes"
            echo "  --confirm                 Prompt for confirmation before applying each change"
            echo "  --only-files=<pattern>    Only apply changes to files matching pattern"
            echo "  --ignore-files=<pattern>  Ignore changes for files matching pattern"
            echo "  --help, -h                Show this help message"
            exit 0
            ;;
        *) echo "Unknown parameter: $1"; exit 1 ;;
    esac
done

# Create backup directory if needed
if [ "$BACKUP" = true ] && [ ! -d "$BACKUP_DIR" ]; then
    if [ "$DRY_RUN" = false ]; then
        mkdir -p "$BACKUP_DIR"
    elif [ "$VERBOSE" = true ]; then
        echo "[DRY RUN] Would create backup directory: $BACKUP_DIR"
    fi
fi

# Read markdown content from stdin
MARKDOWN=$(cat)

# Create temporary directory
TEMP_DIR=$(mktemp -d)
BLOCKS_FILE="$TEMP_DIR/blocks.txt"
FILES_FILE="$TEMP_DIR/files.txt"

# Function to cleanup temporary files
cleanup() {
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# Extract code blocks and their file names
extract_blocks() {
    local current_file=""
    local in_block=false
    local block_content=""
    
    # Split markdown into lines
    echo "$MARKDOWN" | while IFS= read -r line; do
        # Check if line starts a code block with a file name
        if [[ "$line" =~ ^[[:space:]]*\`\`\`([a-zA-Z0-9\+\-]+)[[:space:]]+(.+) ]]; then
            current_file="${BASH_REMATCH[2]}"
            in_block=true
            block_content=""
            continue
        fi
        
        # Check if line starts a code block without a file name (ignore these)
        if [[ "$line" =~ ^[[:space:]]*\`\`\`([a-zA-Z0-9\+\-]+)[[:space:]]*$ ]]; then
            in_block=false
            current_file=""
            continue
        fi
        
        # Check if line ends a code block
        if [[ "$line" =~ ^[[:space:]]*\`\`\`[[:space:]]*$ ]]; then
            if [ -n "$current_file" ] && [ "$in_block" = true ]; then
                # Save block to a file
                echo "$current_file" >> "$FILES_FILE"
                echo "$block_content" > "$TEMP_DIR/$current_file"
                
                # Format file path for output consistency
                current_file_formatted=$(echo "$current_file" | sed 's/^\.\///')
                if [ "$VERBOSE" = true ]; then
                    echo "Found code block for file: $current_file_formatted"
                fi
            fi
            in_block=false
            current_file=""
            continue
        fi
        
        # Collect content if inside a block
        if [ "$in_block" = true ] && [ -n "$current_file" ]; then
            if [ -z "$block_content" ]; then
                block_content="$line"
            else
                block_content="$block_content"$'\n'"$line"
            fi
        fi
    done
}

# Apply a single code block to a file
apply_block() {
    local file="$1"
    local content_file="$TEMP_DIR/$file"
    local skipped=false
    
    # Check if file should be ignored
    if [ -n "$IGNORE_FILES" ] && [[ "$file" == $IGNORE_FILES ]]; then
        if [ "$VERBOSE" = true ]; then
            echo "Skipping ignored file: $file"
        fi
        return
    fi
    
    # Check if file should be included
    if [ -n "$ONLY_FILES" ] && [[ "$file" != $ONLY_FILES ]]; then
        if [ "$VERBOSE" = true ]; then
            echo "Skipping file not matching include pattern: $file"
        fi
        return
    fi
    
    # Ensure the content file exists
    if [ ! -f "$content_file" ]; then
        echo "Error: Content file not found for $file"
        return
    fi
    
    # Check if target file exists
    if [ ! -f "$file" ]; then
        if [ "$CREATE_MISSING" = true ]; then
            # Create the directory if it doesn't exist
            if [ "$DRY_RUN" = false ]; then
                mkdir -p "$(dirname "$file")"
                cat "$content_file" > "$file"
                echo "Created file: $file"
            elif [ "$VERBOSE" = true ]; then
                echo "[DRY RUN] Would create file: $file"
                echo "---"
                cat "$content_file"
                echo "---"
            else
                echo "[DRY RUN] Would create file: $file"
            fi
        else
            echo "Warning: File does not exist and --create-missing not specified: $file"
        fi
        return
    fi
    
    # Check if content is unchanged
    if [ "$SKIP_UNCHANGED" = true ]; then
        diff -q "$file" "$content_file" > /dev/null
        if [ $? -eq 0 ]; then
            if [ "$VERBOSE" = true ]; then
                echo "Skipping unchanged file: $file"
            fi
            skipped=true
        fi
    fi
    
    # Apply changes if not skipped
    if [ "$skipped" = false ]; then
        # Check if changes are needed
        local changes=$(diff -u "$file" "$content_file")
        if [ -z "$changes" ]; then
            if [ "$VERBOSE" = true ]; then
                echo "No changes needed for: $file"
            fi
            return
        fi
        
        # Show changes if verbose
        if [ "$VERBOSE" = true ]; then
            echo "Changes for $file:"
            echo "$changes"
            echo ""
        else
            echo "Modifying: $file"
        fi
        
        # Ask for confirmation if needed
        if [ "$CONFIRM" = true ]; then
            read -p "Apply changes to $file? (y/n) " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Skipping file: $file"
                return
            fi
        fi
        
        # Create backup if needed
        if [ "$BACKUP" = true ]; then
            local backup_file="$BACKUP_DIR/$(basename "$file").$(date +%Y%m%d%H%M%S).bak"
            if [ "$DRY_RUN" = false ]; then
                cp "$file" "$backup_file"
                if [ "$VERBOSE" = true ]; then
                    echo "Created backup: $backup_file"
                fi
            elif [ "$VERBOSE" = true ]; then
                echo "[DRY RUN] Would create backup: $backup_file"
            fi
        fi
        
        # Apply changes
        if [ "$DRY_RUN" = false ]; then
            cat "$content_file" > "$file"
            echo "Updated file: $file"
        else
            echo "[DRY RUN] Would update file: $file"
        fi
    fi
}

# Main process
if [ "$VERBOSE" = true ]; then
    echo "Starting markdown code application..."
    if [ "$DRY_RUN" = true ]; then
        echo "Running in DRY RUN mode (no changes will be applied)"
    fi
fi

# Extract code blocks from markdown
extract_blocks

# Check if any code blocks were found
if [ ! -f "$FILES_FILE" ] || [ ! -s "$FILES_FILE" ]; then
    echo "No code blocks found in the markdown input."
    exit 0
fi

# Process each code block
while IFS= read -r file; do
    apply_block "$file"
done < "$FILES_FILE"

# Show summary
file_count=$(wc -l < "$FILES_FILE")
if [ "$VERBOSE" = true ]; then
    echo ""
    echo "Process complete."
    echo "Found $file_count code blocks in the markdown input."
    if [ "$DRY_RUN" = true ]; then
        echo "This was a dry run. No changes were applied."
    fi
fi

exit 0
